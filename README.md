# GarageFlow – приложение, позволяющее оптимизировать работу автосервиса и взаимодействие клиента с мастером.
Полный отчёт прикрепленн в репозитории.



## Состав команды:
- Молотов Кирил Дмитриевич - гр. 5130904/20103
- Скалисусов Константин Геннадьевич - гр. 5130904/20105
- Кончев Максим Денисович - гр. 5130904/20105
- Крючкова Кира Юрьевна - гр. 5130904/20105

## Этапы
### Проблема
На данный момент многие автосервисы испытывают ряд проблем, связанных с отслеживанием наличия деталей и ведением учета потребителей, также автовладельцы сталкиваются с неудобствами, вызванными отсутствием единой системы, позволяющей отслеживать процесс работы в реальном времени. Во избежание утери информации и возможных последующих конфликтов на почве недопониманий, было принято решение по созданию единой системы для автосервисов и автовладельцев для их упрощенной коммуникации, оптимизации процессов и надежности хранения данных.

### Цель

Создание CRM системы для оптимизации процесса обслуживания в автосервисе.


### Выработка требований
Jobs to be done
|Сегмент |	Автовладелец |	Мастер|
|---------|---------------|-----------|
|Цели |	Следить за процессом ремонта машины |	Оптимизировать процесс работы|
|Задачи |	Отслеживать процесс работы, вовремя забрать машину |	Обновлять статус работ по машине|
|Действия |	Зарегистрировался в приложении, отслеживает процесс работы, забирает машину |	Зарегистрировался в приложении, поставил машину на внутренний учет, вовремя обновил статус всех работ|
|Описание |	Приложение поможет отслеживать работу мастера в реальном времени |	Приложение поможет оптимизировать работу и коммуникацию с клиентом|


#### Пользовательские истории (User Story)
•	От имени пользователя:

  1.	Когда моя машина будет на новом этапе ремонта, я зайду в личный кабинет и нажму на кнопку «Подробнее…» в разделе «Текущий ремонт», чтобы узнать об этом и быть уверенным, что меня не обманут о проведенных     работах и конечной стоимости ремонта.
  2.	Когда моя машина будет на последнем этапе ремонта, я зайду в личный кабинет и нажму на кнопку «Подробнее…» в разделе «Текущий ремонт», чтобы спланировать свое время и забрать автомобиль вовремя.

•	От имени мастера:

  1.	Когда ко мне приходит новый клиент, я завожу ему его собственный аккаунт с помощью кнопки «Добавить нового пользователя», чтобы во время следующего обращения знать, какие ремонтные работы проводились до      этого.
  2.	Когда цены на детали повышаются, я зайду во вкладку «Прайс-лист» и нажму на кнопку «Редактировать», чтобы изменить цены на свои услуги систематизированно, чтобы не терять время на подсчет итоговой суммы      при каждом обращении.
  3.	Когда я приступаю к осмотру машины, я зайду во вкладку «Прайс-лист» и выберу нужную мне модель машины, нажав на кнопку «Выбрать модель авто», чтобы иметь список возможных работ по конкретной модели, чтобы    сразу оценить свои возможности и огласить цену клиенту.


#### Контракты API:

•	Эндпоинты (URL, методы: GET/POST)
•	Параметры запроса и ответа (обязательные поля)
•	Коды ответов (200 OK, 400 Bad Request, 500 Server Error)
•	Авторизация (токены, API-ключи)
Нефункциональные требования на время отклика
•	Среднее время ответа API: ≤ 200 мс (для 95% запросов)
•	Максимальное время ответа в пиковой нагрузке: ≤ 500 мс
•	Допустимая задержка при 99-м перцентиле (p99): ≤ 1 сек


#### Разработка архитектуры и детальное проектирование
Технологический стек
•	Бэкенд: Python (Django), DRF
•	Фронтенд: Python (Django)
•	СУБД: PostgreSQL
•	Инфраструктура: Docker
•	Инструменты разработки: Git
•	Внешняя зависимость: https://vpic.nhtsa.dot.gov/api/

#### Характер нагрузки на сервис
•	Соотношение R/W нагрузки
  o	Нагрузка записей: 30%; максимальная загрузка системы 5000 WPS (writes per seconds)
  o	Нагрузка чтения: 70%; максимальная загрузка системы 7000 RPS (reads per seconds)
•	Объемы трафика
  o	Средний объем передаваемых данных — 256 Мб/час, пиковый — 512 МБ/час
  o	Входящий трафик — 200 Мбит/с, исходящий — 100 Мбит/с
•	Объемы дисковой системы
  o	Начальный объем данных 10 Гб
  o	Рекомендуемый объем хранилища с расчетом на 3 года: 100 Гб




#### Схема масштабирования сервиса
Для масштабирования сервиса будет использовано горизонтальное масштабирование
•	Для базы данных используем шардирование и кэш для разгрузки
•	Для Python приложения разделяем на микросервисы, каждый из которых масштабируется независимо
•	Для асинхронной обработки запросов используем Kafka
•	Для отслеживания нагрузки на систему может быть использована locust

### Сборка

### Команды для работы с проектом

Все они описаны в [Makefile](Makefile)

#### build-prod

```
❯ make build-prod
```
Запустит сборку проекта для размещения на сервере.

#### build-dev
```
❯ make build-dev
```
Запустит проект в <code>dev</code> режиме

#### startapp
```
❯ make startapp name={app}
```
Создает новое приложение в <code>apps</code> с указанным названием

#### build-unit-test
```
❯ make build-unit-test
```
Запустит unit тесты

#### build-integration-test
```
❯ make build-integration-test
```
Запустит интеграционные тесты

Запуск нагрузочного тестрования необходимо производить в корневой папке

locust -f dct/apps/api/tests/load/test_order_load.py --host=http://localhost:8000

#### Результаты тестов описано в отчете
